[
{
	"uri": "https://compositionalit.github.io/farmer/api-overview/resources/storage-account/",
	"title": "Storage Account",
	"tags": [],
	"description": "",
	"content": "Overview The Storage Account builder creates storage accounts and their associated containers.\n Storage Accounts (Microsoft.Storage/storageAccounts) Storage Containers (blobServices/containers)  Builder Keywords    Keyword Purpose     name Specifies the name of the storage account   sku Sets the SKU of the storage account   add_public_container Adds a general-purpose public storage container   add_private_container Adds a general-purpose private storage container   add_blob_container Adds a general-purpose private blob container    Configuration Members    Member Purpose     Key Returns an ARM expression to retrieve the storage account\u0026rsquo;s primary connection string. Useful for e.g. supplying the connection string to another resource e.g. KeyVault or an app setting in the App Service.    Example open Farmer\ropen Farmer.Resources\rlet storage = storageAccount {\rname \u0026#34;isaacssuperstorage\u0026#34;\rsku Sku.PremiumLRS\radd_public_container \u0026#34;myPublicContainer\u0026#34;\radd_private_container \u0026#34;myPrivateContainer\u0026#34;\radd_blob_container \u0026#34;myBlobContainer\u0026#34;\r}\r"
},
{
	"uri": "https://compositionalit.github.io/farmer/about/",
	"title": "About",
	"tags": [],
	"description": "",
	"content": "About Farmer Farmer is an open source, free to use .NET domain-specific-language (DSL) for rapidly generating non-complex Azure Resource Manager (ARM) templates.\nFor those of you working with Azure today, you may already be aware that one of the most useful features is the ability to generate entire infrastructure architectures as code via ARM Template files. These templates contain a declarative model that allows repeatable deployments and idempotent releases (among other things).\nWhat\u0026rsquo;s wrong with ARM? Unfortunately, ARM templates have several limitations. For example, templates are authored in a JSON dialect. This means not only that it can be verbose, but also contains very limited type checking and support which makes creating templates difficult. It also requires \u0026ldquo;embedded\u0026rdquo;, difficult-to-maintain stringly-typed code in order to achieve what might be trivial in a \u0026ldquo;proper\u0026rdquo; programming language, such as references, variables and parameters - or writing elements such as loops.\nIn other words, whilst working with ARM templates that have already been created is relatively straightforward, the authoring of the templates themselves is time-consuming and error-prone.\nWhilst there have been some recent improvements to ARM - including tooling improvements in VS Code through an extension - we think that we can do much better than relying on tooling for a specific IDE, and this means looking at something apart from JSON when directly authoring ARM templates.\nHow does Farmer work? Farmer templates are simple .NET Core applications which reference the Farmer NuGet package. This package contains a set of types to model ARM resources in a strongly-typed and succinct fashion, as well as functionality to create ARM templates and even deploy directly to Azure.\nWhat can I use Farmer for? Farmer currently has support for the following resources.\n Storage App Service Functions Azure Search Application Insights Cosmos DB Azure SQL Virtual Machines  "
},
{
	"uri": "https://compositionalit.github.io/farmer/quickstarts/quickstart-1/",
	"title": "Your First Template",
	"tags": [],
	"description": "",
	"content": "Introduction In this exercise, you\u0026rsquo;ll:\n create a web application with a fully-configured Application Insights instance create an ARM deployment object and assign the web app to it generate an ARM template  Creating a web app Create an F# console application using the .NET SDK:\ndotnet new console -lang F# -n FarmerSample\rAdd a reference to the Farmer nuget package by modifying the FarmerSample.fsproj as follows:\n\u0026lt;PackageReference Include=\u0026#34;Farmer\u0026#34; Version=\u0026#34;0.3.0\u0026#34;/\u0026gt;\rBuild the project to download the dependency.\nDefining a Farmer web application Open Program.fs and delete all the contents.\n In Farmer, resources are defined using special code blocks that look somewhat json-esque, known as a \u0026ldquo;builder\u0026rdquo;. In these builders you can quickly and easily configure a resource using special keywords, but unlike json you also have edit-time safety.\n Create a Farmer web application using the webApp { } builder:\nopen Farmer\ropen Farmer.Resources\rlet myWebApp = webApp {\rname \u0026#34;yourFirstFarmerApp\u0026#34;\r}\r You should pick something unique for the name. It must be unique across Azure i.e. someone else can\u0026rsquo;t have another web app with the same name!\n Create an ARM template deployment object, before setting the location for the overall resource group and adding the web app into it.\nlet deployment = arm {\rlocation Locations.NorthEurope\radd_resource myWebApp\r}\rGenerating the ARM template Now you need to generate the ARM template from the deployment object to an ARM json file.\nAdd the following code:\nlet filename =\rdeployment.Template\r|\u0026gt; Writer.toJson\r|\u0026gt; Writer.toFile \u0026#34;myFirstTemplate\u0026#34;\rRun the application; you should notice that the file myFirstTemplate.json has been created.\nThe generated ARM template contains the following resources:\n A web application A server farm An application insights instance  The resources will be correctly configured with the appropriate dependencies set.\nThe full application open Farmer\ropen Farmer.Resources\rlet myWebApp = webApp {\rname \u0026#34;yourFirstFarmerApp\u0026#34;\r}\rlet deployment = arm {\rlocation Locations.NorthEurope\radd_resource myWebApp\r}\rlet filename =\rdeployment.Template\r|\u0026gt; Writer.toJson\r|\u0026gt; Writer.toFile \u0026#34;myFirstTemplate\u0026#34;\r"
},
{
	"uri": "https://compositionalit.github.io/farmer/api-overview/writer/",
	"title": "Writing templates",
	"tags": [],
	"description": "",
	"content": "Farmer supports several ways to \u0026ldquo;output\u0026rdquo; ARM templates.\nGenerating JSON as string You can generate an ARM template as a plain string:\nlet json =\rdeployment.Template\r|\u0026gt; Writer.toJson\r// prints out the JSON\r printfn \u0026#34;%s\u0026#34; json\rWriting to a file You can also write out the JSON directly to a file:\n// myTemplate.json\rlet filename =\rdeployment.Template\r|\u0026gt; Writer.toJson\r|\u0026gt; Writer.toFile \u0026#34;myTemplate\u0026#34;\r Notice how we use F#\u0026lsquo;s pipe operator to \u0026ldquo;pipe\u0026rdquo; data from the template configuration into json before writing to a file.\n Generating a deployment batch file You can create a batch file that will deploy the template to Azure when run. It uses an interactive login prompt via the Azure CLI.\n// farmer-deploy.bat\rlet filename =\rdeployment\r|\u0026gt; Writer.generateDeployScript \u0026#34;myResourceGroup\u0026#34;\r This assumes that you have the Azure CLI installed on your machine.\n Deploying directly to Azure You can also create the template itself and the associated batch file, and the launch it as a single command.\ndeployment\r|\u0026gt; Writer.quickDeploy \u0026#34;myResourceGroup\u0026#34;\r"
},
{
	"uri": "https://compositionalit.github.io/farmer/api-overview/resources/web-app/",
	"title": "Web App",
	"tags": [],
	"description": "",
	"content": "Overview The Web App builder is used to create Azure App Service accounts. It abstracts the Service Plan into the same component, and will also create and configure a linked App Insights resource.\n Web Site (Microsoft.Web/sites) Web Host (Microsoft.Web/serverfarms) Application Insights (Microsoft.Insights/components) Site Extension (siteextensions)  Builder Keywords    Keyword Purpose     name Sets the name of the web app.   service_plan_name Sets the name of the service plan. If not set, uses the name of the web app postfixed with \u0026ldquo;-plan\u0026rdquo;.   sku Sets the sku of the service plan.   worker_size Sets the size of the service plan worker.   number_of_workers Sets the number of instances on the service plan.   app_insights_auto_name Sets the name of the automatically-created app insights instance.   app_insights_off Removes any automatic app insights creation, configuration and settings for this webapp.   app_insights_manual Instead of creating a new AI instance, configure this webapp to point to another AI instance that you are managing yourself.   run_from_package Sets the web app to use \u0026ldquo;run from package\u0026rdquo; deployment capabilities.   website_node_default_version Sets the node version of the web app.   setting Sets an app setting of the web app in the form \u0026ldquo;key\u0026rdquo; \u0026ldquo;value\u0026rdquo;.   depends_on Sets a dependency for the web app.   always_on Sets \u0026ldquo;Always On\u0026rdquo; flag.   runtime_stack Sets the runtime stack.   operating_system Sets the operating system.    Configuration Members    Member Purpose     PublishingPassword Gets the ARM expression path to the publishing password of this web app.    Example open Farmer\ropen Farmer.Resources\rlet myWebApp = webApp {\rname \u0026#34;myWebApp\u0026#34;\rservice_plan_name \u0026#34;myServicePlan\u0026#34;\rsetting \u0026#34;myKey\u0026#34; \u0026#34;aValue\u0026#34;\rsku Sku.B1\ralways_on\rapp_insights_off\rworker_size Medium\rnumber_of_workers 3\rrun_from_package\r}\r"
},
{
	"uri": "https://compositionalit.github.io/farmer/quickstarts/quickstart-2/",
	"title": "Creating a linked resource",
	"tags": [],
	"description": "",
	"content": "Introduction In this quickstart, you\u0026rsquo;ll expand on the deployment authored in the previous quickstart as follows:\n add an Azure storage account add an application setting to the web app that references the storage account\u0026rsquo;s key set a dependency between the two resources  Creating a storage account Create a storage account by using the storageAccount builder.\nlet myStorage = storageAccount {\rname \u0026#34;yourfirststorage\u0026#34;\r}\r Azure Storage Account names must be globally unique and between 3-24 alphanumeric lower-case characters:\n Referencing the storage account in the web app In this section, we will add an app setting to the web app and set the value to the storage account\u0026rsquo;s connection string.\n In F#, you need to define a value before you reference it, so make sure that you define the storage account above the web app.\n Add the storage account\u0026rsquo;s connection key to the webapp as an app setting.\nlet myWebApp = webApp {\r...\rsetting \u0026#34;STORAGE_CONNECTION\u0026#34; myStorage.Key\r}\r Settings can be strings or (as in this case) an ARM expression, which is evaluated at deployment time.\n Setting a dependency on the storage account In ARM templates, you need to explicitly set up dependencies between resources that refer to one another; this is still required in Farmer. This tells Azure to create the storage account before it creates the web app.\nlet myWebApp = webApp {\r...\rdepends_on myStorage\r}\rAdding the storage account to the deployment Add the storage account to the deployment using the same add_resource keyword as you did with myWebApp.\nAnalysing the ARM template Run the application; you should notice that the template now contains a storage account. Also observe the dependency that has been created:\n{\r\u0026#34;resources\u0026#34;: [\r{\r\u0026#34;apiVersion\u0026#34;: \u0026#34;2016-08-01\u0026#34;,\r\u0026#34;dependsOn\u0026#34;: [\r\u0026#34;yourfirststorage\u0026#34;\r],\r\u0026#34;type\u0026#34;: \u0026#34;Microsoft.Web/sites\u0026#34;\r}\r]\r}\rAlso observe the application setting that has been created:\n{\r\u0026#34;appSettings\u0026#34;: [\r{\r\u0026#34;name\u0026#34;: \u0026#34;storageKey\u0026#34;,\r\u0026#34;value\u0026#34;: \u0026#34;[concat(\u0026#39;DefaultEndpointsProtocol=https;AccountName=yourfirststorage;AccountKey=\u0026#39;, listKeys(\u0026#39;yourfirststorage\u0026#39;, \u0026#39;2017-10-01\u0026#39;).keys[0].value)]\u0026#34;\r}\r]\r}\rThe full application open Farmer\ropen Farmer.Resources\rlet myStorageAccount = storageAccount {\rname \u0026#34;yourfirststorageaccount\u0026#34;\r}\rlet myWebApp = webApp {\rname \u0026#34;yourFirstFarmerApp\u0026#34;\rsetting \u0026#34;storageKey\u0026#34; myStorageAccount.Key\rdepends_on myStorageAccount.Name\r}\rlet deployment = arm {\rlocation NorthEurope\radd_resource myStorageAccount\radd_resource myWebApp\r}\rlet filename =\rdeployment.Template\r|\u0026gt; Writer.toJson\r|\u0026gt; Writer.toFile \u0026#34;myFirstTemplate\u0026#34;\r"
},
{
	"uri": "https://compositionalit.github.io/farmer/quickstarts/",
	"title": "Quickstarts",
	"tags": [],
	"description": "",
	"content": "This section contains quickstarts to performing common tasks.\n Creating your first Farmer template Creating linked resources  "
},
{
	"uri": "https://compositionalit.github.io/farmer/api-overview/parameters/",
	"title": "Parameters and Variables",
	"tags": [],
	"description": "",
	"content": "ARM templates support the idea both of parameterisation of templates and of the use of variables within a template for e.g. placeholders and re-using values.\nFarmer, by design, has only limited support for parameters and no support for variables. We don\u0026rsquo;t plan on adding rich support for either of these for the following reasons:\n We want to keep the Farmer codebase simple for maintainers We want to keep the Farmer API simple for users We want to keep the generated ARM templates as readable as possible We feel that instead of trying to embed conditional logic and program flow directly inside ARM templates in JSON, if you wish to parameterise your template that you should use a real programming language to do that: in this case, F#.  You can read more on this issue here\nSecure Parameters Farmer does support securestring parameters for e.g. SQL and Virtual Machine passwords - these are automatically generated based on the contents of the template rather than explicitly by yourself.\nFor example, assume the following Farmer SQL resource:\nlet db = sql {\rserver_name \u0026#34;myserver\u0026#34;\rdb_name \u0026#34;mydatabase\u0026#34;\radmin_username \u0026#34;mradmin\u0026#34;\r}\rThis will generate an ARM template which looks as follows (irrelevant content is elided for clarity):\n{\r\u0026#34;$schema\u0026#34;: \u0026#34;https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#\u0026#34;,\r\u0026#34;parameters\u0026#34;: {\r\u0026#34;password-for-myserver\u0026#34;: {\r\u0026#34;type\u0026#34;: \u0026#34;securestring\u0026#34;\r}\r},\r\u0026#34;resources\u0026#34;: [\r{\r\u0026#34;apiVersion\u0026#34;: \u0026#34;2014-04-01-preview\u0026#34;,\r\u0026#34;name\u0026#34;: \u0026#34;myserver\u0026#34;,\r\u0026#34;properties\u0026#34;: {\r\u0026#34;administratorLogin\u0026#34;: \u0026#34;mradmin\u0026#34;,\r\u0026#34;administratorLoginPassword\u0026#34;: \u0026#34;[parameters(\u0026#39;password-for-myserver\u0026#39;)]\u0026#34;,\r},\r\u0026#34;type\u0026#34;: \u0026#34;Microsoft.Sql/servers\u0026#34;\r}\r]\r}\rWorking with variables ARM templates allow you to declare variables inside a template to reuse a value across a template. ARM templates also allow the use of a custom set of a commands which are embedded within strings to generate program logic, using expressions which contain template functions. For example, to concatinate a string inside a ARM template made up of two variables and put into a third variable, you might use something like the following:\n{\r\u0026#34;variables\u0026#34;: {\r\u0026#34;first\u0026#34;: \u0026#34;Hello\u0026#34;,\r\u0026#34;second\u0026#34;: \u0026#34;World\u0026#34;,\r\u0026#34;serverName\u0026#34;: \u0026#34;[concat(variables(\u0026#39;first\u0026#39;), \u0026#39; \u0026#39;, variables(\u0026#39;second\u0026#39;), \u0026#39;!\u0026#39;)]\u0026#34;\r}\r}\rIn F#, you have access to the full power of .NET, rather than a limited set of weakly-typed functions:\nlet first = \u0026#34;Hello\u0026#34;\rlet second = \u0026#34;World\u0026#34;\rlet serverName = first + \u0026#34;\u0026#34; + second + \u0026#34;!\u0026#34;\rlet dbName = sprintf \u0026#34;%s %s!\u0026#34; first second\rlet db = sql {\rserver_name serverName\rdb_name dbName\radmin_username \u0026#34;mradmin\u0026#34;\r}\rRapidly creating multiple resources You can also use F# list comprehensions to rapidly create several resources of the same type:\n// Create five SQL servers and databases\rlet myDatabases =\r[ for i in 1 .. 5 -\u0026gt;\rsql {\rserver_name (sprintf \u0026#34;server%d\u0026#34; i)\rdb_name (sprintf \u0026#34;database%d\u0026#34; i)\radmin_username \u0026#34;mradmin\u0026#34;\r}\r]\r// Add all five databases to the deployment\rlet deployment = arm {\rlocation NorthEurope\radd_resources myDatabases\r}\r"
},
{
	"uri": "https://compositionalit.github.io/farmer/api-overview/",
	"title": "API Overview",
	"tags": [],
	"description": "",
	"content": "API aims The key guiding principles of the Farmer API are (in order):\n Simplicity: Make it as easy as possible to do the most common tasks. Type safety: Where possible, use F#\u0026lsquo;s type system to make it impossible to create invalid templates. Flexibility: Provide users with the ability to override the defaults where needed.  Farmer Resources Farmer works on a simple, consistent process:\n You create Farmer resources, such as Storage Accounts and Web Apps. Each Farmer resource can represent one or many ARM resources. For example, a Farmer webApp resource represents both the Microsoft.Web/sites and Microsoft.Web/serverfarms resources. In addition, it optionally also provides simplified access to an Microsoft.Insights/components. You configure each resource using simple, human-readable custom keywords in a strongly-typed environment. You link together resources as required. Once you have created all resources, you bundle them up together into an ARM deployment resource. You then generate (and optionally deploy) an ARM template. The rest of your deployment pipeline stays the same.  The diagram below illustrates how Farmer resources map to ARM ones:\nIn this example, we create a storage account and web app in Farmer, which maps six different ARM template resources. As you can see, resources in Farmer are declared at a higher level of abstraction than ARM template resources. This makes things much simpler to reason about, and quicker to author.\nAn example Farmer Resource All Farmer resources follow the same approach:\n You define a resource using a special \u0026ldquo;builder\u0026rdquo; that allows the use of custom keywords. This is known as an F# computation expression. Each builder is designed for a specific type of Azure resource e.g. websites, functions, virtual machines etc., and each has defaults set for the most common scenario. This resource is validated and converted into a Farmer configuration object, which contains the configuration for that resource including any defaults. This configuration is then added to an overarching Farmer ARM deployment object. The ARM deployment object is converted into an ARM template json file.  Here\u0026rsquo;s an example web application.\nlet myWebApp = webApp {\rname \u0026#34;mystorage\u0026#34;\rsetting \u0026#34;myKey\u0026#34; \u0026#34;aValue\u0026#34;\rsku Sku.B1\ralways_on\rapp_insights_off\rworker_size WorkerSize.Medium\rnumber_of_workers 3\rrun_from_package\r}\r The webApp { } builder defines the start and end of the definition of the web application. Within this builder, you use custom keywords to configure the web app, such as name and setting. Some keywords take arguments, but others e.g. always_on are simple declarative markers.   You can view details of all farmer resources in the resource guide.\n Putting it all together The diagram above can be shown in code as follows:\n/// An Azure Storage account with a container.\rlet storage = storageAccount {\rname \u0026#34;astorageaccount\u0026#34;\radd_public_container \u0026#34;myContainer\u0026#34;\r}\r/// An Azure App Service with built-in App Insights.\rlet app = webApp {\rname \u0026#34;awebapp\u0026#34;\rsetting \u0026#34;storageKey\u0026#34; storage.Key // pull in the storage key to an app setting\r depends_on storage // state that this web app depends on the storage account\r}\r/// An ARM deployment with both of the above resources attached\rlet deployment = arm {\rlocation NorthEurope\radd_resource storage\radd_resource app\r}\r// Write the ARM template out to myTemplate.json\rlet filename =\rdeployment.Template\r|\u0026gt; Writer.toJson\r|\u0026gt; Writer.toFile \u0026#34;myTemplate\u0026#34;\r"
},
{
	"uri": "https://compositionalit.github.io/farmer/api-overview/resources/app-insights/",
	"title": "App Insights",
	"tags": [],
	"description": "",
	"content": "Overview The App Insights builder is used to create Application Insights accounts. Use this if you need a standalone AI instance; if you need one for a web app, the web app will create one by default and configure the application settings automatically.\n Application Insights (Microsoft.Insights/components)  Builder Keywords    Keyword Purpose     name Sets the name of the App Insights instance.    Configuration Members    Member Purpose     InstrumentationKey /// Gets the ARM expression path to the instrumentation key of this App Insights instance.    Example open Farmer\ropen Farmer.Resources\rlet ai = appInsights {\rname \u0026#34;myAI\u0026#34;\r}\r"
},
{
	"uri": "https://compositionalit.github.io/farmer/api-overview/resources/functions/",
	"title": "Functions",
	"tags": [],
	"description": "",
	"content": "Overview The Functions builder is used to create Azure Functions accounts. It abstracts the App Host and Service Plan into the same component, and will also create and configure a linked App Insights resource. In addition, it will automatically create a backing storage account required by the functions runtime.\n Web Site (Microsoft.Web/sites) Web Host (Microsoft.Web/serverfarms) Application Insights (Microsoft.Insights/components) Site Extension (siteextensions) Storage Accounts (Microsoft.Storage/storageAccounts)  Builder Keywords    Keyword Purpose     name Sets the name of the functions instance.   service_plan_name Sets the name of the service plan hosting the function instance.   storage_account_link Do not create an automatic storage account; instead, link to a storage account that is created outside of this Functions instance.   app_insights_auto_name Sets the name of the automatically-created app insights instance.   app_insights_off Removes any automatic app insights creation, configuration and settings for this webapp.   app_insights_manual Instead of creating a new AI instance, configure this webapp to point to another AI instance that you are managing yourself.   use_runtime Sets the runtime of the Functions host.   use_extension_version Sets the extension version of the functions host.   operating_system Sets the operating system of the Functions host.   setting Sets an app setting of the web app in the form \u0026ldquo;key\u0026rdquo; \u0026ldquo;value\u0026rdquo;.   depends_on Sets a dependency for the web app.    Configuration Members    Member Purpose     PublishingPassword Gets the ARM expression path to the publishing password of this functions app.   StorageAccountKey Gets the ARM expression path to the storage account key of this functions app.   AppInsightsKey Gets the ARM expression path to the app insights key of this functions app, if it exists.   DefaultKey Gets the ARM expression path for the default key of this functions app.   MasterKey Gets the ARM expression path for the master key of this functions app.    Example let myFunctions = functions {\rname \u0026#34;myWebApp\u0026#34;\rservice_plan_name \u0026#34;myServicePlan\u0026#34;\rsetting \u0026#34;myKey\u0026#34; \u0026#34;aValue\u0026#34;\rapp_insights_off\r}\r"
},
{
	"uri": "https://compositionalit.github.io/farmer/quickstarts/quickstart-3/",
	"title": "Deploying a Farmer template",
	"tags": [],
	"description": "",
	"content": "Introduction In this exercise, you\u0026rsquo;ll update the application to deploy the generated ARM template to Azure directly from Farmer.\nInstall the Azure CLI If you haven\u0026rsquo;t done so already, install the Azure CLI on your machine.\nDeploy the template As Farmer emits standard ARM templates, you can use all the standard ARM template deployment tools at your disposal - whether that\u0026rsquo;s Visual Studio, Powershell, or the Azure CLI. In our case, we can also use Farmer\u0026rsquo;s API which wraps around the Azure CLI.\nModify the application you created at the end of quickstart #2 so that instead of writing the template to a file, we deploy it directly:\ndeployment\r|\u0026gt; Writer.quickDeploy \u0026#34;myResourceGroup\u0026#34;\rFarmer will now create the ARM template, and also generate a batch / shell script which calls the Azure CLI. You\u0026rsquo;ll be prompted to login to Azure by the CLI, after which point it will create the named resource group in the location specified in the arm { } builder.\nWait until the process is completed and log into the Azure Portal. Navigate to the newly-created resource group and inspect the overview record list e.g.\nCongratulations - you\u0026rsquo;ve now created and deployed an ARM template entirely from F#!\nThe full application open Farmer\ropen Farmer.Resources\rlet myStorageAccount = storageAccount {\rname \u0026#34;yourfirststorageaccount\u0026#34;\r}\rlet myWebApp = webApp {\rname \u0026#34;yourFirstFarmerApp\u0026#34;\rsetting \u0026#34;storageKey\u0026#34; myStorageAccount.Key\rdepends_on myStorageAccount.Name\r}\rlet deployment = arm {\rlocation NorthEurope\radd_resource myStorageAccount\radd_resource myWebApp\r}\rdeployment\r|\u0026gt; Writer.quickDeploy \u0026#34;myResourceGroup\u0026#34;\r"
},
{
	"uri": "https://compositionalit.github.io/farmer/api-overview/expressions/",
	"title": "ARM Expressions",
	"tags": [],
	"description": "",
	"content": "ARM template expressions are a way of safely storing string values which contain expressions that are evaluated at deployment time by the Azure. ARM expressions can also contain a set of predefined functions supported by the ARM runtime.\nFarmer understands how to use ARM expressions and provides functionality to correctly wrap and unwrap them as raw strings into a JSON template.\n For manipulation of literal values that are known on the client, you will not need to use ARM expressions. To manipulate such values, you can use standard F# and .NET capabilities.\n How do I use ARM expressions? Many Farmer builders contain pre-defined ARM expression that can be used for common tasks, such as passing a connection string from a storage account as a KeyVault secret, or a web application setting.\nAs an example, a Storage Account config contains a Key member that you can supply this to a web app as a setting:\nlet storageConfig = storageAccount {\rname \u0026#34;myStorageAccount\u0026#34;\r}\rlet webAppConfig = webApp {\rname \u0026#34;myWebApp\u0026#34;\rsetting \u0026#34;storageKey\u0026#34; storageConfig.Key\r}\rThis will be written to the ARM template file as follows:\n\u0026#34;appSettings\u0026#34;: [\r{\r\u0026#34;name\u0026#34;: \u0026#34;storageKey\u0026#34;,\r\u0026#34;value\u0026#34;: \u0026#34;[concat(\u0026#39;DefaultEndpointsProtocol=https;AccountName=myStorageAccount;AccountKey=\u0026#39;, listKeys(\u0026#39;myStorageAccount\u0026#39;, \u0026#39;2017-10-01\u0026#39;).keys[0].value)]\u0026#34;\r}\rUsing ARM expressions means that you can deploy an application which is automatically configured at deployment time. This means that you never need to store an application secret such as a storage account key in source control, or even e.g. as a secret variable in your build / deployment process.\nCreating your own ARM Expressions Farmer ARM expressions are in reality just wrapped strings, and are easy to create. For example, the code to create the Key property above is similar to this:\nlet buildKey (name : string) : ArmExpression =\r// Create the raw string of the expression\r let rawValue : string =\rsprintf\r\u0026#34;concat(\u0026#39;DefaultEndpointsProtocol=https;AccountName=%s;AccountKey=\u0026#39;, listKeys(\u0026#39;%s\u0026#39;, \u0026#39;2017-10-01\u0026#39;).keys[0].value)\u0026#34;\rname\rname\r// Wrap it in an ARM Expression and return it\r ArmExpression rawValue\rNotice that you do not wrap the expression in square brackets [ ]; Farmer will do this when writing out the ARM template.\n"
},
{
	"uri": "https://compositionalit.github.io/farmer/deployment-guidance/",
	"title": "Deployment Guidance",
	"tags": [],
	"description": "",
	"content": "You can use Farmer in a number of ways:\n As a way to quickly generate your ARM template, which is then committed into source control and deployed as normal by e.g. Azure Dev Ops. Creating a basic ARM template which generates 90% of what you need, after which you will then manually make further changes to the template, and deploy or commit into source control as normal. As a build step in your CD process to generate and deploy your ARM template. In this model, you commit your Farmer code into source control; the ARM template is a transient file that is generated during the build process and deployed into Azure, similar to the relationship between e.g. Typescript and Javascript or C# and a DLL.  The choice is yours.\n"
},
{
	"uri": "https://compositionalit.github.io/farmer/api-overview/resources/virtual-machine/",
	"title": "Virtual Machine",
	"tags": [],
	"description": "",
	"content": "Overview The Virtual Machine builder creates a fully configured virtual machine and all its required child resources.\n Virtual Machines (Microsoft.Compute/virtualMachines) Virtual Networks (Microsoft.Network/virtualNetworks) IP Addresses (Microsoft.Network/publicIPAddresses) Network Interfaces (Microsoft.Network/networkInterfaces)  In addition, every VM you create will add a SecureString parameter to the ARM template, whose name follows the pattern password-for-[virtual machine name].\nBuilder Keywords    Keyword Purpose     name Sets the name of the VM.   diagnostics_support Turns on diagnostics support using either an automatically created or externally created storage account.   vm_size Sets the size of the VM.   username Sets the admin username of the VM (note: the password is supplied as a securestring parameter to the generated ARM template).   operating_system Sets the operating system of the VM. A set of samples is provided in the CommonImages module.   os_disk Sets the size and type of the OS disk for the VM.   add_disk Adds a data disk to the VM with a specific size and type.   add_ssd_disk Adds a SSD data disk to the VM with a specific size.   add_slow_disk Adds a conventional (non-SSD) data disk to the VM with a specific size.   domain_name_prefix Sets the prefix for the domain name of the VM.   address_prefix Sets the IP address prefix of the VM.   subnet_prefix Sets the subnet prefix of the VM.    Configuration Members    Member Purpose     NicName Provides the resource name of the Network Interface Card (NIC)   VnetName Provides the resource name of the Virtual Network (VNet)   SubnetName Provides the resource name of the subnet   IpName Provides the resource name of the IP Address   Hostname Returns an ARM expression to retrieve the fully-qualified domain name from the virtual machine\u0026rsquo;s DNS settings.\u0026rdquo;    Example open Farmer\ropen Farmer.Resources\rlet myVm = vm {\rname \u0026#34;myFarmerVm\u0026#34;\rusername \u0026#34;yourUsername\u0026#34;\rvm_size Size.Standard_A2\roperating_system CommonImages.WindowsServer_2012Datacenter\ros_disk 128 StandardSSD_LRS\radd_ssd_disk 128\radd_slow_disk 512\r}\r"
},
{
	"uri": "https://compositionalit.github.io/farmer/faq/",
	"title": "FAQs",
	"tags": [],
	"description": "",
	"content": "How can I help? Try out Farmer and see what you think.\n Create as many issues as you can for both bugs, discussions and features Create suggestions for features and the most important elements you would like to see added  I have an Azure subscription, but I\u0026rsquo;m not an expert. I like the look of this - how do I \u0026ldquo;use\u0026rdquo; it?  Create an ARM template using the Farmer sample app. Follow the steps here to deploy the generated template into Azure. Log any issues or ideas that you find here.  I don\u0026rsquo;t know F#. Would you consider writing a C# version of this? I\u0026rsquo;m afraid not. F# isn\u0026rsquo;t hard to learn (especially for simple DSLs such as this), and you can easily integrate F# applications as part of a dotnet solution, since F# is a first-class citizen of the dotnet core ecosystem.\nAre you trying to replace ARM templates? No, we\u0026rsquo;re not. Farmer generates ARM templates that can be used just as normal; Farmer can be used simply to make the process of getting started much simpler, or incorporated into your build pipeline as a way to avoid managing difficult-to-manage ARM templates and instead use them as the final part of your build / release pipeline.\nAre you trying to compete with Pulumi? No, we\u0026rsquo;re not. Farmer has (at least currently) a specific goal in mind, which is to lower the barrier to entry for creating and working with ARM templates that are non-complex. We\u0026rsquo;re not looking to create a cross-platform DSL to also support things like Terraform etc. or support deployment of code along with infrastructure (or, at least, only to the extent that ARM templates do).\nThere\u0026rsquo;s no support for variables or parameters! Farmer intentionally has limited support for ARM parameters and variables. Read here to find out the alternatives.\n"
},
{
	"uri": "https://compositionalit.github.io/farmer/api-overview/resources/",
	"title": "Resources",
	"tags": [],
	"description": "",
	"content": "Resources Farmer currently has support for the most popular resources in Azure, such as Storage, App Service and Functions. You can find out more about each resource in detail in the menu.\n"
},
{
	"uri": "https://compositionalit.github.io/farmer/",
	"title": "Farmer",
	"tags": [],
	"description": "",
	"content": "Farmer Farmer is a DSL for rapidly generating non-complex ARM templates in a type-safe manner.\nMain Features  Create non-complex ARM templates through a simple, strongly-typed and pragmatic DSL. Create strongly-typed dependencies to resources. Runs on .NET Core. Use standard F# code to dynamically create ARM templates quickly and easily.  // Create a storage account\rlet myStorageAccount = storageAccount {\rname \u0026#34;myTestStorage\u0026#34;\rsku Sku.PremiumLRS\radd_public_container \u0026#34;myContainer\u0026#34;\r}\r// Create a web app with a pre-configured application insights service\rlet myWebApp = webApp {\rname \u0026#34;myTestWebApp\u0026#34;\rsetting \u0026#34;storageKey\u0026#34; myStorageAccount.Key\rsku Sku.B1\ralways_on\rdepends_on myStorageAccount.Name\r}\r// Create an ARM template\rlet deployment = arm {\rlocation NorthEurope\radd_resource myStorageAccount\radd_resource myWebApp\r}\r"
},
{
	"uri": "https://compositionalit.github.io/farmer/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://compositionalit.github.io/farmer/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]